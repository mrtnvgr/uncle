#!/bin/python
import argparse, os

version = "0.0.3-1"

parser = argparse.ArgumentParser()
parser.add_argument("-c", "--cue")
parser.add_argument("-p", "--path", default="")
parser.add_argument("-r", "--remove", help="remove source file", action="store_true")
parser.add_argument("-rc", "--remove-cue", help="remove source cue file", action="store_true")
parser.add_argument("-j", "--join", help="joins multiple files into one", action="store_true")
parser.add_argument("-d", "--dry", help="only print commands", action="store_true")
parser.add_argument("-v", "--version", action="store_true")
args = parser.parse_args()
if args.version==True:
    print(f"uncle v{version}")
    exit(0)
elif args.cue==None:
    print("error: the following arguments are required: -c/--cue")
    exit(1)

cue = open(args.cue).read().split("\n")

if args.path!="" and not os.path.exists(os.path.join(os.getcwd(), args.path)):
    print("error: path not found")
    exit(1)

def timegen(time):
    minutes,seconds,ticks = time.split(":")
    return f"{minutes}:{seconds}.{ticks}"

rems = {}
tracks = {}
currenttrack = 0
for line in cue:
    cueline = [x for x in line.split(" ") if x!=""]
    if cueline!=[]:
        if cueline[0]=="REM":
            rems[cueline[1]] = " ".join(cueline[2:])
        elif cueline[0]=="FILE":
            rems[cueline[0]] = " ".join(" ".join(cueline[1:]).split(" ")[:-1])
        elif cueline[0]=="PERFORMER" or cueline[0]=="TITLE":
            if currenttrack!=0:
                tracks[currenttrack][cueline[0]] = " ".join(cueline[1:])
            else:
                rems[cueline[0]] = " ".join(cueline[1:])
        elif cueline[0]=="TRACK":
            currenttrack = cueline[1]
            tracks[currenttrack] = {}
        elif cueline[0]=="INDEX":
            if not "INDEX" in tracks[currenttrack].keys():
                tracks[currenttrack]["INDEX"] = cueline[2]
        else:
            print("UNSUPPORTED: " + cueline[0])
tracks = list(tracks.values())
if not args.join:
    for i in range(len(tracks)):
        track = tracks[i]
        if len(tracks)>i+1:
            nexttime = " --until="+timegen(tracks[i+1]['INDEX'])
        else:
            nexttime = ""
        title = track['TITLE'].rstrip('\"') + "." + rems['FILE'].split(".")[-1]
        time = timegen(track['INDEX'])
        metadata = []
        trackdata = rems|track
        for rem in trackdata:
            if trackdata[rem][0]!='"': trackdata[rem] = f'"{trackdata[rem]}"'
            metadata.append(f'-metadata {rem}={trackdata[rem]}')
        execline = f"flac -f -c {rems['FILE']} --skip={time}{nexttime} -o {args.path}{title}"
        if args.dry:
            print(execline)
        else:
            os.system(execline)
            print(f"[{i+1}/{len(tracks)}] "+args.path+title)
    if args.remove:
        try:
            os.remove(rems['FILE'].replace('"',''))
            if args.remove_cue: os.remove(args.cue)
        except Exception as e:
            print(f"error: {e}")
else:
    print("Under construction")
    exit(1)
    # TODO: !!!
    files = []
    for file in tracks:
        title = file['TITLE'].rstrip('\"') + "." + rems['FILE'].split(".")[-1]
        files.append(f"-i {args.path}{title}")
    execline = f"ffmpeg -hide_banner {' '.join(files)} -filter_complex [0:a][1:a]concat=n={len(files)}:v=0:a=1 {rems['FILE']}"
    if args.dry:
        print(execline)
    else:
        os.system(execline)
        print("PLACEHOLDER !TODO!")
    if args.remove:
        for file in files:
            try:
                os.remove(file.split("file '")[1][:-1])
            except Exception as e:
                print(f"error: {e}")
